# syntax=docker/dockerfile:1.7

# 0) Build args (overridable in CI)
ARG BUILDER_IMAGE=alpine:3.20
{{- if not .Metadata.Image.Distroless }}
ARG RUNTIME_IMAGE=debian:bookworm
ARG USER=noroot
{{- else}}
ARG RUNTIME_IMAGE=gcr.io/distroless/base-debian12:nonroot
{{- end}}
ARG UID=65532
ARG GID=65532

# 1) Use a lightweight builder image with package manager to fetch tini.
# builder stage does not compile go source files.
FROM ${BUILDER_IMAGE} AS builder

# Work directory
WORKDIR /workspace

# Install minimal tools required to download files securely
RUN apk add --no-cache curl ca-certificates

# Download the static tini binary (example for amd64); use a different file for other architectures
# Then make it executable so it can be used as PID 1 in the final image
RUN curl -fsSL -o /usr/bin/tini https://github.com/krallin/tini/releases/download/v0.19.0/tini-static-amd64 \
 && chmod +x /usr/bin/tini

# 2) Runtime stage
FROM ${RUNTIME_IMAGE} AS runtime

ARG OS
ARG ARCH
{{- if not .Metadata.Image.Distroless }}
ARG USER
{{- end}}
ARG UID
ARG GID

# App directory
WORKDIR /app

{{- if not .Metadata.Image.Distroless }}

# Install runtime essentials
RUN apt-get update \
 && apt-get install -y --no-install-recommends ca-certificates tzdata wget curl telnet \
 && rm -rf /var/lib/apt/lists/*

# Security: create a non-root user (ignore if it already exists)
# Use || true to prevent build failures if the group/user already exists in the base image
RUN groupadd -g ${GID} ${USER} 2>/dev/null || true \
 && useradd -u ${UID} -g ${USER} ${USER} 2>/dev/null || true
{{- end}}

# Copy artifact and set ownership; numeric UID:GID is more robust
COPY --from=builder --chown=0:0 /usr/bin/tini /usr/bin/tini
COPY --chown=${UID}:${GID} _output/platforms/${OS}/${ARCH}/{{.Web.BinaryName}} /app/{{.Web.BinaryName}}

# Security: run as non-root
USER ${UID}:${GID}

# Use tini as minimal init to handle signals and reap zombies
ENTRYPOINT ["/usr/bin/tini", "--", "/app/{{.Web.BinaryName}}"]
